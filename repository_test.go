package friendlymongo_test

import (
	"context"
	"testing"

	fm "github.com/pmatteo/friendlymongo"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

var basicAddress = &address{
	Street: "Main St",
	Number: 123,
	City:   "Springfield",
}

func TestInserts(t *testing.T) {
	t.Run("DefaultInsert", testDefaultInsert)
	t.Run("TestInsertMany", testInsertMany)
}

// Test InsertOne method with a custom model and letting the library generate the ObjectID.
func testDefaultInsert(t *testing.T) {
	t.Parallel()

	model := newCustomModel("Autogenerated ID", "autogeneratedID@test.com", true, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	require.NotNil(t, model.ID)
	assert.NotEqual(t, primitive.NilObjectID, model.ID)
	assert.NotEmpty(t, model.CreatedAt)
	assert.NotEmpty(t, model.UpdatedAt)
}

func testInsertMany(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("Insert Many 1", "many1@test.com", true, basicAddress),
		newCustomModel("Insert Many 2", "many2@test.com", true, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)
}

func TestFinds(t *testing.T) {
	t.Run("TestFindOne", testFindOne)
	t.Run("TestFindMany", testFindMany)
}

// Test FindOne method with a custom model.
func testFindOne(t *testing.T) {

	t.Parallel()

	filter := bson.M{"name": "Autogenerated ID"}
	expectedModel := &customModel{
		Name:    "Autogenerated ID",
		Email:   "autogeneratedID@test.com",
		Active:  true,
		Address: basicAddress,
	}

	found, err := repo.FindOne(context.Background(), filter)
	require.NoError(t, err)

	require.NotNil(t, found)

	require.NotNil(t, found.ID)
	assert.NotEqual(t, primitive.NilObjectID, found.ID)

	assert.NotEmpty(t, found.CreatedAt)
	assert.NotEmpty(t, found.UpdatedAt)
	assert.Equal(t, expectedModel.Name, found.Name)
	assert.Equal(t, expectedModel.Email, found.Email)
	assert.True(t, expectedModel.Active, found.Active)
	assert.NotEmpty(t, found.ActivationDate)
	assert.Equal(t, expectedModel.Address.Street, found.Address.Street)
	assert.Equal(t, expectedModel.Address.Number, found.Address.Number)
	assert.Equal(t, expectedModel.Address.City, found.Address.City)
}

func testFindMany(t *testing.T) {
	t.Parallel()

	filter := bson.M{
		"name": bson.M{
			"$regex": primitive.Regex{
				Pattern: "^Insert Many.*",
				Options: "",
			},
		},
	}
	models, err := repo.Find(context.Background(), filter)
	require.NoError(t, err)

	require.Len(t, models, 2)

	assert.Equal(t, "Insert Many 1", models[0].Name)
	assert.Equal(t, "Insert Many 2", models[1].Name)
}

func TestUpdateOne_WithBsonM(t *testing.T) {

	model := newCustomModel("to update with bsonM", "toupdate.withbsonM@test.com", false, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	filter := bson.M{"email": "toupdate.withbsonM@test.com"}

	updated, err := repo.UpdateOne(context.Background(), filter, bson.M{"$set": bson.M{"active": false}})
	require.NoError(t, err)

	assert.Equal(t, model.ID, updated.ID)
	assert.False(t, updated.Active)
}

func TestUpdateOne_WithModel(t *testing.T) {
	model := newCustomModel("to update with model", "toupdate.withmodel@test.com", false, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	updated, err := repo.UpdateOne(
		context.Background(),
		bson.M{"email": "toupdate.withmodel@test.com"},
		newCustomModel("to update with model", "toupdate.withmodel@test.com", true, basicAddress),
	)
	require.NoError(t, err)

	assert.Equal(t, model.ID, updated.ID)
	assert.False(t, updated.Active)
}

func TestDelete_Many(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("to delete many 1", "todelete1@test.com", false, basicAddress),
		newCustomModel("to delete many 2", "todelete2@test.com", false, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	filter := bson.M{
		"name": bson.M{
			"$regex": primitive.Regex{
				Pattern: "^to delete many.*",
				Options: "",
			},
		},
	}
	c, err := repo.Delete(context.Background(), filter)
	require.NoError(t, err)

	require.Equal(t, int64(2), c)
}

func TestDelete_One(t *testing.T) {
	t.Parallel()

	model := newCustomModel("to delete", "todelete@test.com", false, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	filter := bson.M{"email": "todelete@test.com"}
	c, err := repo.Delete(context.Background(), filter)
	require.NoError(t, err)

	require.Equal(t, int64(1), c)
}

func TestReplaceOne(t *testing.T) {
	t.Parallel()

	model := newCustomModel("to replace", "toreplace@test.com", false, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	replace := &customModel{
		Name:  "replaced",
		Email: "replaced@test.com",
	}

	filter := bson.M{
		"email": "toreplace@test.com",
	}
	err = repo.ReplaceOne(context.Background(), filter, replace)
	require.NoError(t, err)

	found, err := repo.FindOne(context.Background(), bson.M{
		"email": "replaced@test.com",
	})
	require.NoError(t, err)

	assert.NotNil(t, model)
	assert.False(t, model.ID.IsZero())
	assert.Equal(t, model.ID, found.ID)
	assert.Equal(t, "replaced", found.Name)
}

func TestAggregate_Simple(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("to aggregate 1", "aggregate2@test.com", false, basicAddress),
		newCustomModel("to aggregate 2", "aggregate1@test.com", false, basicAddress),
		newCustomModel("to aggregate 3", "aggregate3@test.com", true, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	pipeline := mongo.Pipeline{
		{{Key: "$match", Value: bson.M{"active": false}}},
		{{Key: "$match", Value: bson.M{"name": bson.M{"$regex": "^to aggregate.*"}}}},
		{{Key: "$sort", Value: bson.M{"name": 1}}},
	}

	var result []*customModel
	err = repo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 2)
	assert.Equal(t, "to aggregate 1", result[0].Name)
	assert.Equal(t, "to aggregate 2", result[1].Name)
}

func TestAggregate_WithBuilder(t *testing.T) {

	t.Parallel()

	models := []*customModel{
		newCustomModel("aggregate builder 1", "aggregate_builder1@test.com", false, basicAddress),
		newCustomModel("aggregate builder 2", "aggregate_builder2@test.com", false, basicAddress),
		newCustomModel("aggregate builder 3", "aggregate_builder3@test.com", true, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	pipeline := fm.
		NewStageBuilder().
		Match("stg1", bson.M{"active": false}).
		Append("stg1", bson.M{"email": bson.M{"$regex": "^aggregate_builder.*"}}).
		Group("stg3", bson.M{"_id": nil, "names": bson.M{"$push": "$name"}}).
		Sort("stg4", bson.M{"names": 1}).
		Build()

	var result []*struct {
		Names []string `bson:"names"`
	}
	err = repo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 1)
	assert.Len(t, result[0].Names, 2)
	assert.Equal(t, "aggregate builder 1", result[0].Names[0])
	assert.Equal(t, "aggregate builder 2", result[0].Names[1])
}

func TestAggregate_Count(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("aggregate count 1", "aggregate_count1@test.com", false, basicAddress),
		newCustomModel("aggregate count 2", "aggregate_count2@test.com", false, basicAddress),
		newCustomModel("aggregate count 3", "aggregate_count3@test.com", true, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	pipeline := fm.
		NewStageBuilder().
		Match("stg1", bson.M{"active": false}).
		Match("stg2", bson.M{"name": bson.M{"$regex": ".*count.*"}}).
		Count("stg4", "count").
		Build()

	var result []struct {
		Count int `bson:"count"`
	}
	err = repo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 1)
	assert.Equal(t, result[0].Count, 2)
}

func TestAggregate_LookupOtherCollection(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("aggregate lookup 1", "aggregate_lookup@test.com", false, basicAddress),
		newCustomModel("aggregate lookup 2", "aggregate_lookup@test.com", false, basicAddress),
		newCustomModel("aggregate lookup 3", "aggregate_lookup@test.com", true, basicAddress),
	}
	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	var otherRepo = newOtherModelRepo()
	otherModels := []*otherModel{
		{
			FK:          models[0].ID,
			Group:       "admin",
			Permissions: []string{"read", "write"},
		},
		{
			FK:          models[1].ID,
			Group:       "admin",
			Permissions: []string{"read"},
		},
		{
			FK:          models[2].ID,
			Group:       "user",
			Permissions: []string{"write"},
		},
	}
	err = otherRepo.InsertMany(context.Background(), otherModels)
	require.NoError(t, err)

	pipeline := fm.
		NewStageBuilder().
		Match("stg1", bson.M{"name": bson.M{"$regex": "^aggregate lookup.*"}}).
		Lookup("stg2", "otherCollection", "_id", "fk", "other").
		Match("stg3", bson.M{"other.group": "admin"}).
		Build()

	var result []struct {
		Name  string `bson:"name"`
		Other []struct {
			Group       string   `bson:"group"`
			Permissions []string `bson:"permissions"`
		} `bson:"other"`
	}

	err = repo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 2)
}

func TestAggregate_Unwind(t *testing.T) {

	t.Parallel()

	var otherRepo = newOtherModelRepo()
	otherModels := []*otherModel{
		{
			FK:          primitive.NewObjectID(),
			Group:       "admin unwind",
			Permissions: []string{"read", "write"},
		},
	}

	err := otherRepo.InsertMany(context.Background(), otherModels)
	require.NoError(t, err)

	pipeline := fm.
		NewStageBuilder().
		Match("stg1", bson.M{"group": bson.M{"$regex": ".*unwind.*"}}).
		Unwind("stgw", "$permissions").
		Build()

	var result []struct {
		Permission string             `bson:"permissions"`
		FK         primitive.ObjectID `bson:"fk"`
		Group      string             `bson:"group"`
	}

	err = otherRepo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 2)
}

func TestAggregate_SortByCount(t *testing.T) {

	t.Parallel()

	models := []*customModel{
		newCustomModel("aggregate sortByCount 1", "sortByCount1@test.com", false, basicAddress),
		newCustomModel("aggregate sortByCount 2", "sortByCount2@test.com", false, basicAddress),
		newCustomModel("aggregate sortByCount 3", "sortByCount3@test.com", true, basicAddress),
	}
	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	pipeline := fm.NewStageBuilder().
		Match("stg1", bson.M{"email": bson.M{"$regex": ".*sortByCount.*"}}).
		SortByCount("stg2", "$active").Build()

	var result []struct {
		Count int `bson:"count"`
	}
	err = repo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 2)
	assert.Equal(t, result[0].Count, 2)
	assert.Equal(t, result[1].Count, 1)
}

func TestAggregate_Bucket(t *testing.T) {

	t.Parallel()

	pipeline := fm.
		NewStageBuilder().
		Bucket("stg1", "$year", []any{1900, 1910, 1920, 1930, 1940}, "other", bson.M{
			"count": bson.M{"$sum": 1},
		})

	var result []struct {
		ID    any `bson:"_id"`
		Count int `bson:"count"`
	}

	err := artworksRepo.Aggregate(context.Background(), pipeline.Build(), &result)
	require.NoError(t, err)

	require.Len(t, result, 5)

	assert.Equal(t, int32(1900), result[0].ID)
	assert.Equal(t, 1, result[0].Count)
	assert.Equal(t, int32(1910), result[1].ID)
	assert.Equal(t, 1, result[1].Count)
	assert.Equal(t, int32(1920), result[2].ID)
	assert.Equal(t, 2, result[2].Count)
	assert.Equal(t, int32(1930), result[3].ID)
	assert.Equal(t, 1, result[3].Count)
	assert.Equal(t, "other", result[4].ID)
	assert.Equal(t, 1, result[4].Count)

}

func TestAggregate_Facet(t *testing.T) {

	t.Parallel()

	pipeline := fm.
		NewStageBuilder().
		Facet("stg1", map[string]*fm.StageBuilder{
			"categorizedByTags": fm.NewStageBuilder().Unwind("stg1", "$tags").SortByCount("stg2", "$tags"),
			"categorizedByPrice": fm.NewStageBuilder().
				Match("stg1", bson.M{"price": bson.M{"$exists": true}}).
				Bucket("stg2", "$price", []any{0, 150, 200, 300, 400}, "Other", bson.M{
					"count":  bson.M{"$sum": 1},
					"titles": bson.M{"$push": "$title"},
				}),
		})

	var result []struct {
		CategorizedByTags []struct {
			ID string `bson:"_id"`
		} `bson:"categorizedByTags"`
		CategorizedByPrice []struct {
			ID     any      `bson:"_id"`
			Count  int      `bson:"count"`
			Titles []string `bson:"titles"`
		} `bson:"categorizedByPrice"`
	}

	err := artworksRepo.Aggregate(context.Background(), pipeline.Build(), &result)
	require.NoError(t, err)

	require.Len(t, result, 1)
	assert.Len(t, result[0].CategorizedByTags, 10)
	assert.Len(t, result[0].CategorizedByPrice, 5)
}
