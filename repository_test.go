package friendlymongo_test

import (
	"context"
	"testing"

	"github.com/pmatteo/friendlymongo"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

var basicAddress = &address{
	Street: "Main St",
	Number: 123,
	City:   "Springfield",
}

func TestInserts(t *testing.T) {
	t.Run("DefaultInsert", testDefaultInsert)
	t.Run("TestInsertMany", testInsertMany)
}

// Test InsertOne method with a custom model and letting the library generate the ObjectID.
func testDefaultInsert(t *testing.T) {
	t.Parallel()

	model := newCustomModel("Autogenerated ID", "autogeneratedID@test.com", true, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	require.NotNil(t, model.ID)
	assert.NotEqual(t, primitive.NilObjectID, model.ID)
	assert.NotEmpty(t, model.CreatedAt)
	assert.NotEmpty(t, model.UpdatedAt)
}

func testInsertMany(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("Insert Many 1", "many1@test.com", true, basicAddress),
		newCustomModel("Insert Many 2", "many2@test.com", true, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)
}

func TestFinds(t *testing.T) {
	t.Run("TestFindOne", testFindOne)
	t.Run("TestFindMany", testFindMany)
}

// Test FindOne method with a custom model.
func testFindOne(t *testing.T) {

	t.Parallel()

	filter := bson.M{"name": "Autogenerated ID"}
	expectedModel := &customModel{
		Name:    "Autogenerated ID",
		Email:   "autogeneratedID@test.com",
		Active:  true,
		Address: basicAddress,
	}

	found, err := repo.FindOne(context.Background(), filter)
	require.NoError(t, err)

	require.NotNil(t, found)

	require.NotNil(t, found.ID)
	assert.NotEqual(t, primitive.NilObjectID, found.ID)

	assert.NotEmpty(t, found.CreatedAt)
	assert.NotEmpty(t, found.UpdatedAt)
	assert.Equal(t, expectedModel.Name, found.Name)
	assert.Equal(t, expectedModel.Email, found.Email)
	assert.True(t, expectedModel.Active, found.Active)
	assert.NotEmpty(t, found.ActivationDate)
	assert.Equal(t, expectedModel.Address.Street, found.Address.Street)
	assert.Equal(t, expectedModel.Address.Number, found.Address.Number)
	assert.Equal(t, expectedModel.Address.City, found.Address.City)
}

func testFindMany(t *testing.T) {
	t.Parallel()

	filter := bson.M{
		"name": bson.M{
			"$regex": primitive.Regex{
				Pattern: "^Insert Many.*",
				Options: "",
			},
		},
	}
	models, err := repo.Find(context.Background(), filter)
	require.NoError(t, err)

	require.Len(t, models, 2)

	assert.Equal(t, "Insert Many 1", models[0].Name)
	assert.Equal(t, "Insert Many 2", models[1].Name)
}

func TestUpdateOne_WithBsonM(t *testing.T) {

	model := newCustomModel("to update with bsonM", "toupdate.withbsonM@test.com", false, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	filter := bson.M{"email": "toupdate.withbsonM@test.com"}

	updated, err := repo.UpdateOne(context.Background(), filter, bson.M{"$set": bson.M{"active": false}})
	require.NoError(t, err)

	assert.Equal(t, model.ID, updated.ID)
	assert.False(t, updated.Active)
}

func TestUpdateOne_WithModel(t *testing.T) {
	model := newCustomModel("to update with model", "toupdate.withmodel@test.com", false, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	updated, err := repo.UpdateOne(
		context.Background(),
		bson.M{"email": "toupdate.withmodel@test.com"},
		newCustomModel("to update with model", "toupdate.withmodel@test.com", true, basicAddress),
	)
	require.NoError(t, err)

	assert.Equal(t, model.ID, updated.ID)
	assert.False(t, updated.Active)
}

func TestDelete_Many(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("to delete many 1", "todelete1@test.com", false, basicAddress),
		newCustomModel("to delete many 2", "todelete2@test.com", false, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	filter := bson.M{
		"name": bson.M{
			"$regex": primitive.Regex{
				Pattern: "^to delete many.*",
				Options: "",
			},
		},
	}
	c, err := repo.Delete(context.Background(), filter)
	require.NoError(t, err)

	require.Equal(t, int64(2), c)
}

func TestDelete_One(t *testing.T) {
	t.Parallel()

	model := newCustomModel("to delete", "todelete@test.com", false, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	filter := bson.M{"email": "todelete@test.com"}
	c, err := repo.Delete(context.Background(), filter)
	require.NoError(t, err)

	require.Equal(t, int64(1), c)
}

func TestReplaceOne(t *testing.T) {
	t.Parallel()

	model := newCustomModel("to replace", "toreplace@test.com", false, basicAddress)

	err := repo.InsertOne(context.Background(), model)
	require.NoError(t, err)

	replace := &customModel{
		Name:  "replaced",
		Email: "replaced@test.com",
	}

	filter := bson.M{
		"email": "toreplace@test.com",
	}
	err = repo.ReplaceOne(context.Background(), filter, replace)
	require.NoError(t, err)

	found, err := repo.FindOne(context.Background(), bson.M{
		"email": "replaced@test.com",
	})
	require.NoError(t, err)

	assert.NotNil(t, model)
	assert.Equal(t, model.ID, found.ID)
	assert.Equal(t, "replaced", found.Name)
}

func TestAggregate_Simple(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("to aggregate 1", "aggregate2@test.com", false, basicAddress),
		newCustomModel("to aggregate 2", "aggregate1@test.com", false, basicAddress),
		newCustomModel("to aggregate 3", "aggregate3@test.com", true, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	pipeline := mongo.Pipeline{
		{{Key: "$match", Value: bson.M{"active": false}}},
		{{Key: "$match", Value: bson.M{"name": bson.M{"$regex": "^to aggregate.*"}}}},
		{{Key: "$sort", Value: bson.M{"name": 1}}},
	}

	var result []*customModel
	err = repo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 2)
	assert.Equal(t, "to aggregate 1", result[0].Name)
	assert.Equal(t, "to aggregate 2", result[1].Name)
}

func TestAggregate_WithBuilder(t *testing.T) {

	t.Parallel()

	models := []*customModel{
		newCustomModel("aggregate builder 1", "aggregate_builder1@test.com", false, basicAddress),
		newCustomModel("aggregate builder 2", "aggregate_builder2@test.com", false, basicAddress),
		newCustomModel("aggregate builder 3", "aggregate_builder3@test.com", true, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	pipeline := friendlymongo.
		NewStageBuilder().
		Match("stg1", bson.M{"active": false}).
		Append("stg1", bson.M{"email": bson.M{"$regex": "^aggregate_builder.*"}}).
		Group("stg3", bson.M{"_id": nil, "names": bson.M{"$push": "$name"}}).
		Sort("stg4", bson.M{"names": 1}).
		Build()

	var result []*struct {
		Names []string `bson:"names"`
	}
	err = repo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 1)
	assert.Len(t, result[0].Names, 2)
	assert.Equal(t, "aggregate builder 1", result[0].Names[0])
	assert.Equal(t, "aggregate builder 2", result[0].Names[1])
}

func TestAggregate_Count(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("aggregate count 1", "aggregate_count1@test.com", false, basicAddress),
		newCustomModel("aggregate count 2", "aggregate_count2@test.com", false, basicAddress),
		newCustomModel("aggregate count 3", "aggregate_count3@test.com", true, basicAddress),
	}

	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	pipeline := friendlymongo.
		NewStageBuilder().
		Match("stg1", bson.M{"active": false}).
		Match("stg2", bson.M{"name": bson.M{"$regex": ".*count.*"}}).
		Count("stg4", "count").
		Build()

	var result []struct {
		Count int `bson:"count"`
	}
	err = repo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 1)
	assert.Equal(t, result[0].Count, 2)
}

func TestAggregate_LookupOtherCollection(t *testing.T) {
	t.Parallel()

	models := []*customModel{
		newCustomModel("aggregate lookup 1", "aggregate_lookup@test.com", false, basicAddress),
		newCustomModel("aggregate lookup 2", "aggregate_lookup@test.com", false, basicAddress),
		newCustomModel("aggregate lookup 3", "aggregate_lookup@test.com", true, basicAddress),
	}
	err := repo.InsertMany(context.Background(), models)
	require.NoError(t, err)

	var otherRepo = newOtherModelRepo()
	otherModels := []*otherModel{
		{
			FK:          models[0].ID,
			Group:       "admin",
			Permissions: []string{"read", "write"},
		},
		{
			FK:          models[1].ID,
			Group:       "admin",
			Permissions: []string{"read"},
		},
		{
			FK:          models[2].ID,
			Group:       "user",
			Permissions: []string{"write"},
		},
	}
	err = otherRepo.InsertMany(context.Background(), otherModels)
	require.NoError(t, err)

	pipeline := friendlymongo.
		NewStageBuilder().
		Match("stg1", bson.M{"name": bson.M{"$regex": "^aggregate lookup.*"}}).
		Lookup("stg2", bson.M{
			"from":         "otherCollection",
			"localField":   "_id",
			"foreignField": "fk",
			"as":           "other",
		}).
		Match("stg3", bson.M{"other.group": "admin"}).
		Build()

	var result []struct {
		Name  string `bson:"name"`
		Other []struct {
			Group       string   `bson:"group"`
			Permissions []string `bson:"permissions"`
		} `bson:"other"`
	}

	err = repo.Aggregate(context.Background(), pipeline, &result)
	require.NoError(t, err)

	require.Len(t, result, 2)
}
